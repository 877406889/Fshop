# 架构师直通车

## 环境搭建

### 1. 导入pom文件

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>com.jdd</groupId>
    <artifactId>Fshop</artifactId>
    <version>1.0-SNAPSHOT</version>
    <!--  子模块  -->
<!--    1.聚合工程里面可以分为（顶级工程、父工程）与子工程，这两者的关系其实就是父子继承的关系-->
<!--    子工程在maven里称之为模块（module），模块之间是平级，是可以项目依赖的-->
<!--    2.子模块可以使用顶级工程里所有的资源（依赖），子模块之间如果要使用资源，必须构建依赖关系（构建关系）-->
<!--    3.一个顶级工程是可以由多个不同的子工程共同组成的-->
    <modules>
        <module>Fshop-common</module>
        <module>Fshop-pojo</module>
        <module>Fshop-mapper</module>
        <module>Fshop-service</module>
        <module>Fshop-api</module>
    </modules>
    <!--打包方式-->
    <packaging>pom</packaging>

    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>2.1.5.RELEASE</version>
        <relativePath />
    </parent>

    <properties>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
        <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>
        <java.version>1.8</java.version>
    </properties>

    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter</artifactId>
<!--            <exclusions>-->
<!--                &lt;!&ndash;       用来排除springboot的日志jar包         &ndash;&gt;-->
<!--                <exclusion>-->
<!--                    <groupId>org.springframework.boot</groupId>-->
<!--                    <artifactId>spring-boot-starter-logging</artifactId>-->
<!--                </exclusion>-->
<!--            </exclusions>-->
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-configuration-processor</artifactId>
            <optional>true</optional>
        </dependency>
        <!-- mysql驱动 -->
        <dependency>
            <groupId>mysql</groupId>
            <artifactId>mysql-connector-java</artifactId>
            <version>5.1.41</version>
        </dependency>
<!--         mybatis -->
        <dependency>
            <groupId>org.mybatis.spring.boot</groupId>
            <artifactId>mybatis-spring-boot-starter</artifactId>
            <version>2.1.0</version>
        </dependency>
<!--         https://mvnrepository.com/artifact/tk.mybatis/mapper-spring-boot-starter -->
        <dependency>
            <groupId>tk.mybatis</groupId>
            <artifactId>mapper-spring-boot-starter</artifactId>
            <version>2.1.5</version>
        </dependency>


    </dependencies>

</project>
```

### 2. 创建子模块

![image-20200520222056694](.\images\image-20200520222056694.png)

### 3.mybats逆向工程生成mapper和pojo

[本项目用的开源项目的逆向工程](https://github.com/abel533/Mapper)

注意配置重点不然错配一个配置都会报错。

### 4.springboot application 配置

```java
############################################################
#
# 配置数据源信息
#
############################################################
spring:
  datasource:                                           # 数据源的相关配置
    type: com.zaxxer.hikari.HikariDataSource          # 数据源类型：HikariCP
    driver-class-name: com.mysql.jdbc.Driver          # mysql驱动
    url: jdbc:mysql://localhost:3306/fshop?useUnicode=true&characterEncoding=UTF-8&autoReconnect=true&useSSL=false
    username: root
    password: L_earn0827
    hikari:
      connection-timeout: 30000       # 等待连接池分配连接的最大时长（毫秒），超过这个时长还没可用的连接则发生SQLException， 默认:30秒
      minimum-idle: 5                 # 最连
      maxium-pool-size: 20           # 最大连接数
      auto-commit: true               # 自动提交
      idle-timeout: 600000            # 连接超时的最大时长（毫秒），超时则被释放（retired），默认:10分钟
      pool-name: DateSourceHikariCP     # 连接池名字
      max-lifetime: 1800000           # 连接的生命时长（毫秒），超时而且没被使用则被释放（retired），默认:30分钟 1800000ms
      connection-test-query: SELECT 1

############################################################
#
# mybatis 配置
#
############################################################
mybatis:
  type-aliases-package: com.jdd.pojo          # 所有POJO类所在包路径
  mapper-locations: classpath:mapper/*.xml      # mapper映射文件
  


############################################################
#
# web访问端口号  约定：8088
#
############################################################
server:
  port: 8088
  tomcat:
    uri-encoding: UTF-8
  max-http-header-size: 80KB

#逆向工程配置
mapper:
  mappers: tk.mybatis.mapper.common.Mapper
```

## 编程环境通用工具类

1. 自定义响应格式

   ```java
   package com.jdd.controller;
   
   import com.jdd.Utils.JDDJSONResult;
   import com.jdd.pojo.bo.UserBo;
   import com.jdd.service.UserService;
   import org.apache.commons.lang3.StringUtils;
   import org.springframework.beans.factory.annotation.Autowired;
   import org.springframework.web.bind.annotation.*;
   
   /**
    * @Author: L_earn
    * @Date: 2020/5/24 23:21
    */
   @RestController
   @RequestMapping("/passport")
   public class PassportController {
   
       @Autowired
       private UserService userService;
   
       @GetMapping("/usernameIsExist")
       public JDDJSONResult usernameIsExist(@RequestParam String username){
           //用户名不能为空
           if (StringUtils.isBlank(username)){
               return JDDJSONResult.errorMap("用户名不能为空");
           }
           //用户名不存在
           if (userService.queryUsernameIsExist(username)){
               return JDDJSONResult.ok();
           }else {
               //用户名已经存在
               return JDDJSONResult.errorMap("用户名已经存在");
           }
       }
   
       @PostMapping("/regist")
       public JDDJSONResult regist(@RequestBody UserBo userBo){
           String username = userBo.getUsername();
           String password = userBo.getPassword();
           String confirmPwd = userBo.getConfirmPassword();
           if (StringUtils.isBlank(username) || StringUtils.isBlank(password) || StringUtils.isBlank(confirmPwd)){
               return JDDJSONResult.errorMsg("参数不能为空");
           }
           boolean isExit = userService.queryUsernameIsExist(username);
           if (!isExit){
               return JDDJSONResult.errorMsg("用户名已存在");
           }
           if (password.length() < 6){
               return JDDJSONResult.errorMsg("密码长度必须大于6位");
           }
           if (!password.equals(confirmPwd)){
               return  JDDJSONResult.errorMsg("两次密码不一致");
           }
           return JDDJSONResult.ok();
       }
   }
   
   ```

   

## spring 事务

### 事务的传播

```java
/**
     *  事务的传播 - Propagation
     *      REQUIRED：使用当前的事务，如果当前没有事务，则自己新建一个事务，子方法是必须运行在
     *      一个事务中的，如果当前存在事务则加入这个事务，成为一个整体。（意思是如果父方法开启事务那么
     *      子类也会被加入该事务）
     *
     *      SUPPORTS：如果当前有事务，则使用事务；如果当前没有事务，则不使用事务。
     *      （可以理解跟随父方法）
     *
     *      MANDATORY：强制，调用被该属性描述的方法时，
     *      调用方必须存在一个事务若不存在则抛出异常
     *      （说明该方法一定要在事务的情况下才可以执行）
     *
     *      REQUIRES_NEW:如果当前有事务则挂起该事务，并且自己创建一个新的事务自己使用
     *      如果当前没有事务，则同REQUIRED
     *
     *      NOT_SUPPORTED:如果当前有事务则挂机，自己不使用事务去运行数据库操作，没有就没有
     *
     *      NEVER:如果当前有事务存在则抛出异常
     *
     *      NESTED:如果当前有事务，则开启子事务（嵌套事务），嵌套事务是独立提交或则回滚；
     *      如果当前没有事务，则同REQUIRED。
     *      但是如果嵌套的父事务提交，则会携带子事务一起提交
     *      如果主事务回滚，则子事务会一起回滚。相反，子事务异常，则父事务可以回滚或不会滚。
     *
     *
     *
     */
```

